
NOTE: Explanatory text edit 05 for 01.04.2020 release starts here

== Conventions

=== Identifiers
The normative provisions in this document are denoted by the URI

http://www.opengis.net/spec/CityGML/3.0

All requirements and conformance tests that appear in this document are denoted by partial URIs which are relative to this base.

=== UML Notation

The CityGML standard is presented in this document in diagrams using the Unified Modeling Language (UML) static structure diagram (see Booch et al. 1997). The UML notations used in this standard are described in the diagram below <<figure-1,Figure 1>>.

[[figure-1]]
.UML notation (see ISO TS 19103, Geographic information - Conceptual schema language).
image::../figures/Figure_1.png[]


All associations between model elements in CityGML are uni-directional. Thus, associations in CityGML are navigable in only one direction. The direction of navigation is depicted by an arrowhead. In general, the context an element takes within the association is indicated by its role. The role is displayed near the target of the association. If the graphical representation is ambiguous though, the position of the role has to be drawn to the element the association points to.

NOTE: Need formal definitions for the sterotypes

The following stereotypes are used:

* \<<FeatureType>> 
* \<<TopLevelFeatureType>>
* \<<type>>
* \<<ObjectType>>
* \<<DataType>>is used as a descriptor of a set of values that lack identity. Data types include primitive prede-fined types and user-definable types. A DataType is thus a class with few or no operations whose primary purpose is to hold the abstract state of another class for transmittal, storage, encoding or persistent storage.
* \<<enumeration>>enumerates the valid attribute values in a fixed list of named literal values. Enumerations are specified in the CityGML schema.
* \<<BasicType>>
* \<<CodeList>>enumerates the valid attribute values. In contrast to Enumeration, the list of values is open and, thus, not given inline the CityGML UML Model. The allowed values can be provided within an external code list.
* \<<Union>>is a list of attributes. The semantics are that only one of the attributes can be present at any time.

NOTE: Update to the current convention

In order to enhance the readability of the CityGML UML diagrams, classes are depicted in different colors if they belong to different UML packages. The following coloring scheme is applied: 

Feature Types: Yellow
TopLevelFeatureType: Orange
Type :Green
ObjectType: Orange
DataType: Blue
Enumration: Purple
Basictype: Brown
Codelist: Pink
Union: Blue

* Classes painted in yellow belong to the UML package which is subject of discussion in that clause of the specification in which the UML diagram is given. For example, in the context of chapter 10.1 which introduces the _CityGML Core_ module, the yellow color is used to denote classes which are defined in the _CityGML Core_ UML package. Likewise, the yellow classes shown in UML diagrams in chapter 10.3 are associated with the _Building_ module which is subject of discussion in that chapter. 
* Classes painted in blue belong to a CityGML UML package different to that associated with the yellow color. In order to explicitly denote the UML package of such classes, their class names carry a naoughout this specification mespace prefix which is uniquely associated with a CityGML module throughout this specification . For example, in the context of the _Building_ module, classes from the _CityGML Core_ module are painted in blue and their class names are preceded by the prefix core. 

The following example UML diagram demonstrates the UML notation and coloring scheme used throughout this specification. In this example, the yellow classes are associated with the _CityGML Building_ module, the blue classes are from the _CityGML Core_ module, and the green class depicts a geometry element defined by GML3.

[[figure-2]]
.Example UML diagram demonstrating the UML notation and coloring scheme used throughout the CityGML specification.
image::../figures/Figure_2.png[]

[[conceptual-modeling-description]]
=== Conceptual Modeling (Informative)

<<iso19101,ISO 19101>> defines universe of discourse to be a view of the real or hypothetical world that includes everything of interest.  That standard then defines conceptual model to be a model that defines concepts of a universe of discourse.

The scope of this CityGML Conceptual Model Standard establishes the limits of the universe of discourse for this Standard. The next task is to discover and standardize the concepts within this scope. CityGML will potentially support numerous diverse application software packages covering multiple disciplines and facility life cycle phases. Each conceivably can have its own universe of discourse and their own set of concepts.

The goal of this CityGML Conceptual Model Standard is to establish and document a common set of concepts that spans the applications supported.  This does not attempt to redefine application concepts, but merely present a common set of concepts from and to which their concepts can be understood and mapped.

GML and JSON encodings are planned and other encodings are anticipated. Each encoding addresses a specific information community and set of application software packages. However, with the increasing desire to share information between communities and applications having a common conceptual model across all of these encodings is highly advantageous.

An added benefit of the development of a conceptual model results from the rigor involved in achieving consensus. After numerous iterations, the end result is consistent, cohesive, and complete.  Updating a conceptual model is far easier than rewriting software code. Further, the iterations help to flesh out details as well as to unearth differences in individual conceptualizations.

Perhaps the greatest benefit of the standards activity is the ability to communicate the resultant model. This is in part due to using a standardized conceptual modelling language like UML and the agreed OGC and TC211 conventions for using UML. The eventual outcome of being able to provide formal documentation for what is meant by each concept is invaluable in understanding the subsequent encodings and applications.

This will be the first OGC conceptual model standard, without accompanying encodings. Yet the model is presented in a manner consistent with the formalisms adopted for writing OGC standards. This standard follows the OGC Specification Model standard for modular specifications [10] and is consistent with the OGC Naming Authority conventions and recommendations.  The target of this Standard are the encoding standards which will follow and not the application software that will implement these encodings.  Requirements for the encodings are explicit and grouped into Requirements Classes.  Accompanying Conformance Classes are included to determine if an encoding conforms to the conceptual model.

UML has been used as the conceptual modeling language in this Standard.  Class Diagrams have been created and inserted as Figures. The boxes in these diagrams (officially “Classifiers” in UML) typically represent classes, data types, enumerations, code lists, unions, etc. and this terminology is used throughout the Standard. However, since this is a Conceptual Model, these should all be interpreted to be “concepts”.  For each Requirements Class, an introductory diagram is included which contains all of the concepts relevant to that Requirements Class.  However, the boxes are simplified by suppressing attributes. These attributes are provided in a series of context diagrams which follow, each focusing on a particular set of concepts in the Requirements Class.

Though redundant with the UML diagrams, all of the class attributes are repeated in the document text, including attribute definitions not visible in the diagrams. If these differ, the UML takes precedence. Because association roles behave similar to attributes, they appear at the end of the textual attribute listing as if they were attributes. The cardinality of the association is depicted as the attribute cardinality and the associated class as the data type.
